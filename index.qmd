---
title: "Nomilo Fishpond Biogoechemical Analysis"
author: "Lysbeth Koster"
date: "02/28/2024"
execute: 
  warning: false
  message: false
code-annotations: hover
code-overflow: wrap
format: 
  html:
    toc-title: "Data Analysis Workflow:"
    toc-location: left
---

::: {.callout-note title="Interactive Code"}
Throughout this document, hover over the numbered annotations to the right of code chunks to reveal detailed explanations and comments about the code. Where drop-down *italicized* text is present, expand by pressing
on arrow to see code.
:::

## Install Packages

```{r}
#| label: install-packages
#| eval: false
install.packages(c("rio", "tidyverse", "janitor", "lubridate", "rmarkdown", "fs", "hms"))
```

## Load Libraries

```{r}
#| label: load-libraries

library(rio) # <1>
library(tidyverse) # <2>
library(janitor) # <3>
library(lubridate) # <4>
library(rmarkdown) # <5>
library(fs) # <6>
library(hms)
```

1. For importing excel data
2. For cleaning of data 
3. For cleaning variable names
4. For cleaning dates
5. For displaying tables
6. For file path usage

## Import Raw Data

### Procedure

Define vector of files to import: 

```{r}
#| label: create-vector-file-paths
files_to_import <- dir_ls(path = "data/raw") # <1>

for (i in seq_along(files_to_import)) { # <2>
  cat(i, "= ", files_to_import[i], "\n") # <2>
} # <2>
```

1. Store the file paths of our raw data within the `data/raw` directory in `files_to_import`
2. Print each file path with its index

Use the `purrr::map()` function to iteratively import files in the `files_to_import` vector 
except for the profiles data and .RData files: 

::: {.callout-caution title="@iteratively-import-raw-data Code Chunk Execution Warning"}
The @iteratively-import-raw-data code chunk should only be ran once when raw data is updated
because it takes long to execute. Therefore, run the @efficiently-load-raw-data code chunk
instead to easily import up-to-date raw data.
:::

```{r}
#| label: iteratively-import-raw-data
#| messages: false
#| warnings: false
#| eval: false
dfs_no_profiles <- map(files_to_import[c(2:4, 6, 7)], import_list) # <1>
current_date <- format(Sys.Date(), "%Y-%m-%d")
save(dfs_no_profiles, file = paste0("data/raw/", current_date, "_dfs-no-profiles.RData")) # <1>
```

::: {.callout-warning title="Ensure the Correct Index Value is Inputted Below"}
Refer to the output of the `files_to_import` data object to ensure you are inputting the correct
index value corresponding to the file path that needs to be loaded.
:::

Efficiently import up-to-date raw data:

```{r}
#| label: efficiently-load-raw-data
load(files_to_import[10])
```

Rename datasets:

We will always use snakecase when naming our data objects and functions (e.g., `data_object_name` or `function_name()`).

```{r}
#| label: rename-raw-datasets
names(dfs_no_profiles) <- gsub("data/raw/2024-02-28_|\\.xlsx$|\\.xls$", "", 
                               files_to_import[c(2:4, 6, 7)]) # <1>
names(dfs_no_profiles) <- gsub("-", "_", names(dfs_no_profiles)) # <2>
names(dfs_no_profiles) # <3>
```

1. Remove prefixes and file extensions
2. Replace hyphens with underscores
3. Check if names were outputted correctly

Rename each sheet within each raw dataset to be lowercased and replace spaces with underscores:

```{r}
#| label: rename-sheets-within-each-raw-dataset
dfs_no_profiles <- map(dfs_no_profiles, ~ set_names(.x, gsub(" ", "_", tolower(names(.x)))))
```

Create separate datasets by specifying the Excel sheet from each spreadsheet we want to tidy:

```{r}
#| label: create-separate-datasets
ksf_clam_growth_data <- dfs_no_profiles$ksf_clam_growth$sheet1
ksf_compiled_data <- dfs_no_profiles$ksf_compiled_data$full_data
ksf_oyster_cylinder_growth_data <- dfs_no_profiles$ksf_oyster_cylinder_growth$sheet1
water_samples_data <- dfs_no_profiles$water_samples$data_overview
weather_data <- dfs_no_profiles$weather_data$weather_ksf
tidal_data <- dfs_no_profiles$ksf_compiled_data$tides
```

We want to combine multiple sheets within the profiles Excel spreadsheet into one, therefore,
we will import it separately:

```{r}
#| label: import-raw-profiles-data
sheets_to_import <- c("L1", "L2", "L3", "L4") # <1>

profiles_data <- profiles_data <- map_dfr(sheets_to_import, function(sheet_name) { # <2>
  import(files_to_import[5], which = sheet_name) # <2>
}) %>%  # <2>
  bind_rows() # <3>
```

1. [code annotation]
2. [code annotation]
3. [code annotation]

### View Raw Data

::: {.panel-tabset}

#### ksf_clam_growth_data

```{r}
#| echo: false
paged_table(ksf_clam_growth_data)
```

#### ksf_compiled_data

```{r}
#| echo: false
paged_table(ksf_compiled_data)
```

#### ksf_oyster_cylinder_growth_data

```{r}
#| echo: false
paged_table(ksf_oyster_cylinder_growth_data)
```

#### water_samples_data

```{r}
#| echo: false
paged_table(water_samples_data)
```

#### weather_data

```{r}
#| echo: false
paged_table(weather_data)
```

#### profiles_data

```{r}
#| echo: false
paged_table(profiles_data)
```

#### tidal_data

```{r}
#| echo: false
paged_table(tidal_data)
```

:::

## Tidy Raw Data

### Tidying Processes

::: {.panel-tabset}

#### ksf_clam_growth_data_tidied

```{r}
#| label: tidy-ksf-clam-growth-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>
new_clam_var_names <- c(
  "sort_date", "color", "clams_in_count", "clams_in_lbs", "clams_in_avg_per_lb", 
  "clams_out_count", "clams_out_lbs", "clams_out_avg_per_lb", "growth_in_lbs",
  "growth_pct", "sr", "days_btwn_sort"
  )

new_clam_date_col <- c(
  "2023-10-17", "2023-12-06", "2023-12-12", "2024-01-02", "2024-01-10", "2024-01-24", 
  "2024-01-31", "2024-02-08", "2024-02-13"
  ) 

ksf_clam_growth_data_tidied <- ksf_clam_growth_data %>%
  slice(-1) %>%
  setNames(new_clam_var_names) %>%
  mutate(date = as.Date(new_clam_date_col)) %>% 
  dplyr::select(-sort_date) %>% 
   pivot_longer(
    cols = c(
      clams_in_count, clams_in_lbs, clams_in_avg_per_lb, clams_out_count, 
      clams_out_lbs, clams_out_avg_per_lb
      ),
    names_to = c("stage", ".value"),
    names_prefix = "clams_", 
    names_sep = "_", 
    values_to = "value"
  ) %>%
  mutate(stage = if_else(str_detect(stage, "in"), "In", "Out")) %>%
  rename(avg_per_lbs = avg) %>% 
  mutate(across(c(color, stage), as.factor)) %>%
  mutate(across(c(count, lbs, avg_per_lbs, growth_in_lbs, growth_pct, sr), 
                ~as.numeric(gsub("%", "", .)))) %>% 
  arrange(date, color, stage) %>% 
  dplyr::select(date, days_btwn_sort, color, stage, count, lbs, avg_per_lbs, 
                growth_in_lbs, growth_pct, sr)

paged_table(ksf_clam_growth_data_tidied)
```

1.
2.
3.
4.
5.
6.

#### ksf_compiled_data_tidied

```{r}
#| label: tidy-ksf-compiled-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>
ksf_compiled_data_tidied <- ksf_compiled_data %>% 
  rename_with(~gsub("\\s*\\([^\\)]+\\)", "", .x)) %>% # <1>
  janitor::clean_names() %>% # <1>
  rename(date = date_time) %>%  # <2>
  mutate(date = as.Date(date)) %>% # <2>
  filter(date >= as.Date("2023-11-20") & date <= as.Date("2024-02-20")) %>% # <2>
  arrange(date) %>%  # <2>
  dplyr::select(-c(external_voltage, wk_num, wind_dir, # <3>
                   spadd, outdoor_temperature, hourly_rain, # <3>
                   solar_radiation, resistivity, battery_capacity, # <3>
                   hour, daynum, data_pt, wind_sp, diradd, # <3>
                   wind_speed, wind_direction, tide, day, month, year) # <3>
                ) %>% # <3>
  dplyr::select(where(~ !anyNA(.))) %>%  # <4>
  group_by(date) %>% # <5>
  summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE))) # <5>

paged_table(ksf_compiled_data_tidied)
```

1. Clean variable names by removing everything in parentheses, using lowercase 
and underscores in place of spaces
2. Rename the `date_time` variable to `date`, filter to desired date range and 
sort by `date`
3. Remove unnecessary variables
4. Remove columns with containing all NA values
5. Group by `date` and calculate the average of every variable for each day

#### ksf_oyster_cylinder_growth_data_tidied

```{r}
#| label: tidy-ksf-oyster-cylinder-growth-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>

oyster_var_names <- c(
  "date", "oyster_large_weight", "oyster_large_gain", "oyster_small_weight",
  "oyster_small_gain", "oyster_chlorophyll"
  ) #<1>

ksf_oyster_cylinder_growth_data_tidied <- ksf_oyster_cylinder_growth_data %>% 
  dplyr::select(c(1, 4, 5, 8, 9, 12)) %>% #<2> 
  slice(-1) %>% #<2>
  setNames(oyster_var_names) %>% #<1>
  pivot_longer( #<3>
    cols = c(oyster_large_weight, oyster_large_gain, #<3>
             oyster_small_gain, #<3>
             oyster_small_weight), #<3>
    names_to = c("oyster_size", ".value"), #<3>
    names_prefix = "oyster_", #<3>
    names_sep = "_", #<3>
    values_to = "value" #<3>
  ) %>% #<3>
  mutate(oyster_size = if_else(str_detect(oyster_size, "small"), "Small", "Large")) %>% #<4>
  mutate(date = as.Date(date), #<5>
         oyster_size = as.factor(oyster_size), #<5>
         across(c(weight, gain), as.numeric) #<5>
        ) %>% #<5>
  filter(date >= as.Date("2023-11-20") & date <= #<6>
           as.Date("2024-02-14")) %>%  #<6>
   mutate_if(is.numeric, ~replace_na(., 0)) #<7>

paged_table(ksf_oyster_cylinder_growth_data_tidied)
```

1. Manually set variable names
2. Select desired columns and remove first row
3. Convert from wide to long format
4. Create a new variable that differentiates oyster size
5. Adjust data types to numeric and factor
6. Filter to desired date range
7. Fill NA values as 0

*Address the NA values before merge*

#### water_samples_data_tidied

```{r}
#| label: tidy-water-samples-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>
water_samples_data_tidied <- water_samples_data %>%
  slice(-c(44:52)) %>% 
  rename_with(~gsub("\\s*\\([^\\)]+\\)", "", .x)) %>% # <1>
  janitor::clean_names() %>% # <1>
  mutate(
    date = if_else(date == "44074", 
                   as.character(as.Date("2024-01-09")),
                   format(dmy(date), "%Y-%m-%d")) 
  ) %>% 
  mutate(sample_id = 1:nrow(.)) %>% 
  mutate(date = as.Date(date),
         across(c(nomilo_id, location, round, depth), as.factor),
         tube_name = as.character(tube_name), 
         tube_name = ifelse(is.na(tube_name), "No Name", tube_name), 
         tube_name = as.factor(tube_name)) %>% 
  mutate_if(is.numeric, ~replace_na(., 0))

paged_table(water_samples_data_tidied)
```

#### weather_data_tidied

```{r}
#| label: tidy-weather-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>
weather_data_tidied <- weather_data %>% 

janitor::clean_names() %>%  #<1>
   unite(date, year, month, day, sep = "-") %>%
  mutate(date = ymd(date)) %>% 
   select(-c(1, 3)) %>% 
  rename("outdoor_temperature" = outdoor_temp_f) %>%
   mutate(outdoor_temperature = (outdoor_temperature - 32) * (5/9)) %>% 
  group_by(date) %>%
  summarise(across(where(is.numeric), \(x) mean(x, na.rm = TRUE))) %>% 
  slice(-1) 

paged_table(weather_data_tidied)
```
janitor names
Date fromat + YYYY/MM/DD
cut 2:6
temp F > C
summarize data per date (daily av)

#### profile_data_tidied

```{r}
#| label: tidy-profile-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>

new_profile_var_names <- c("depth", "water_temperature", "dissolved_oxygen", "salinity", "conductivity", "visibility", "location", "date") 

profiles_data_tidied <- profiles_data %>%
  select(-c(6, 8)) %>% # delete time log and column 8
  mutate(
    temp_column1 = NA_character_, #temporarily create new columns to set the names in next section. We took out 2 so need to fill back in.
    temp_column2 = NA_character_
  ) %>%
  setNames(new_profile_var_names) %>% # assigned new profile var names to rename variables in dataset. 
  mutate(
    location = ifelse(depth == "Location", water_temperature, NA_character_), 
    date = ifelse(depth == "Date", water_temperature, NA_character_) # in depth column there was location and date data. It takes the location from one column and corresponding value from other column.
  ) %>%
  fill(location, date, .direction = "down") %>% # wihtin the location and date column we created, it fills the values from the temperature downwards into the newly created columns for date and location.
  filter(depth != "Location", depth != "Date") %>% # gets rid of the 'location' and 'date' rows. 
  mutate(
    location = case_when(
      location == "L1 Northwest buoy" ~ "back buoy",
      location == "L2 Middle Buoy" ~ "mid buoy",
      location == "L3 Production Dock" ~ "production dock",
      location == "L4 Auwai" ~ "auwei",
      TRUE ~ location # within location column, replace LX value with the correct name. Renaming values. 
    ),
    date = case_when( # same for dates, assigns correct format. 
      date %in% c("45258", "2023-11-28") ~ "2023-11-28",
      date %in% c("45282", "2023-12-22") ~ "2023-12-22",
      date %in% c("45536", "2024-01-09") ~ "2024-01-09",
      date %in% c("30/1/24", "30/01/24") ~ "2024-01-30",
      date %in% c("20/02/24", "20/2/24") ~ "2024-02-20",
      TRUE ~ date
    )) %>%
  mutate(
    date = as.Date(date, format = "%Y-%m-%d"), # change the date type into date format.
    conductivity = case_when(
      row_number() %in% c(1:11) ~ NA_character_,
      TRUE ~ as.character(conductivity) # removes the 1:11 tubidity data. 
    ) 
  ) %>% 
  filter(!(depth %in% c("Samples", "Depth"))) %>% # same as before, looks for rows containing samples and depth names, you filter on that and negate these values through !
  mutate(date = as.Date(date), # correcting data types
         across(c(depth, location), as.factor),
         across(c(water_temperature, dissolved_oxygen, salinity, 
                  conductivity,visibility), as.numeric)) %>% 
   fill(visibility, .direction = "down") %>% # wihtin the location and date column we created, it fills the values from the temperature downwards into the newly created columns for date and location.
  mutate(visibility = if_else(date == "2023-11-28", 0, visibility)) %>% 
   mutate_if(is.numeric, ~replace_na(., 0))
    

paged_table(profiles_data_tidied)
```

*Address the NA values before merge*

#### tidal_data_tidied

```{r}
#| label: tidy-tidal-data-dataset
#| code-fold: true
#| code-summary: <i>Steps to clean data</i>

tidal_data_tidied <- tidal_data %>% 

janitor::clean_names() %>% 
  mutate(date = as.Date(date, format = "%Y-%m-%d")) %>% 
   filter(date >= as.Date("2023-11-20") & date <= as.Date("2024-02-20")) %>% 
  select(-2) %>% 
  mutate(time = as_hms(format(time, "%H:%M:%S")),
         high_low = as.factor(high_low))
  
paged_table(tidal_data_tidied)
```


::: 

### Merge Tidied Datasets

### Export Tidied Datasets

Export tidied datasets to CSV into `data/tidied` folder:

```{r}
#| label: export-tidied-datasets
#| eval: false
source("code/functions/export_to_csv.R")

dfs_to_export <- list( # <1>
  ksf_clam_growth_data_tidied = ksf_clam_growth_data_tidied, # <1>
  ksf_compiled_data_tidied = ksf_compiled_data_tidied, # <1>
  ksf_oyster_cylinder_growth_data_tidied = ksf_oyster_cylinder_growth_data_tidied, # <1>
  water_samples_data_tidied = water_samples_data_tidied, # <1>
  profiles_data_tidied = profiles_data_tidied # <1>
) # <1>

imap(dfs_to_export, ~ export_to_csv(.x, .y, "data/tidied")) # <2>
```

1. List of dataframes we want to export as CSV files
2. Iterate the `export_to_csv(df, df_name, dir_path)` function over each dataframe. 
`.x` refers to the dataframe. `.y` refers to the name of the dataframe. These are 
passed to `export_to_csv()` function along with the desired directory path.


Export merged final data set into `data/outputs` folder.

## Data Dictionary

## Exploratory Data Analysis

## Correlational Analysis